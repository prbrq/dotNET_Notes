
Хоть это и не обязательно, рекомендуется предоставить метод, позволяющий разработчику, использующему ваш тип, явно освобождать ресурсы, чтобы сборщик мусора мог немедленно и детерминированно освободить неуправляемый ресурс, такой как файл, а затем освободить управляемую часть памяти объекта за одну сборку. Для этого существует стандартный механизм - реализация интерфейса IDisposable, как показано в следующем примере:

```cs
public class Animal : IDisposable
{
	public Animal()
	{
		// выделение неуправляемого ресурса
	}
	
	~Animal() // финализатор
	{
		if (disposed) return;
		Dispose(false);
	}
	
	bool disposed = false; // освобождены ли ресурсы?
	
	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}
	
	protected virtual void Dispose(bool disposing)
	{
		if (disposed) return;
		// освобождение *неуправляемого* ресурса
		// ...
		if (disposing)
		{
			// освобождение любых других *управляемых* ресурсов
			// ...
		}
		disposed = true;
	}
}
```

Здесь реализованы два метода `Dispose` — `public` и `private`.

- Открытый метод `public` должен вызываться разработчиком, использующим ваш тип. При вызове открытого метода Dispose необходимо освободить как неуправляемые, так и управляемые ресурсы.
- Защищенный метод `Dispose` (с параметром `bool`) используется для реализации удаления ресурсов. Необходимо проверить параметр `disposing` и флаг `disposed`, поскольку, если финализатор уже запущен, необходимо освободить только неуправляемые ресурсы.

Кроме того, обратите внимание на вызов метода `GC.SuppressFinalize(this)` - он уведомляет сборщик мусора о том, что больше не нужно запускать финализатор, и устраняет необходимость во второй сборке.