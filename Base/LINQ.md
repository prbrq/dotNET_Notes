
Это встроенный в C# механизм для удобной работы с [[Generic Collection|коллекциями]].

Большинство алгоритмов, которые на менее развитых языках принято писать с помощью циклов и условных операторов, более компактно и красиво выражаются с помощью примитивов **LINQ**.

В основе **LINQ** лежит возможно использовать со всеми наследниками [[IEnumerable|IEnumerable<T>]].

---

# Методы фильтрации и преобразования

`Where` используется для фильтрации перечисляемого. Он принимает в качестве параметра функцию-предикат и возвращает новое перечисляемое, состоящее только их тех элементов исходного перечисляемого, на которых предикат вернул `true`.

`Select` используется для поэлементного преобразования перечисляемого. Он принимает в качестве параметра преобразующую функцию и возвращает новое перечисляемое, полученное применением этой функции к каждому элементу исходного перечисляемого.

`Take` обрезает последовательность после указанного количества элементов.

`Skip` обрезает последовательность, пропуская указанное количество элементов с начала.

`ToArray` и `ToList` используется для преобразования `IEnumerable<T>` в массив `T[]` или в `List<T>`, соответственно.

> [!Note] Важно понимать
> Эти методы не меняют исходную коллекцию, а возвращают новую последовательность.

---

# Method Chaining

Несколько последовательных действий с перечислением можно объединить в одну цепочку вызовов. Такой примем называется **Method Chaining**. Однако для улучшения читаемости кода настоятельно рекомендуется каждый вызов метода помещать в отдельную строку, вот так:
```cs
var originalIntArray = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
var resultIntArray = originalIntArray
    .Where(x => x % 2 == 0)
    .Select(x => x * x)
    .Skip(1)
    .Take(2)
    .ToArray();
```

**Method Chaining** делает код компактнее, но скрывает информацию о типах и семантике промежуточных значений. Иногда все же стоит оставлять вспомогательные переменные, чтобы сделать код более читаемым.

---

# SelectMany

Этот метод несколько менее очевиден, чем предыдущие, однако он довольно часто пригождается в самых разных задачах.

В качестве аргумента он принимает функцию, преобразующую каждый элемент исходной последовательности в новую последовательность. Результатом работы является конкатенация всех полученных последовательностей.

Следующий пример пояснит работу этого метода:
```cs
string[] words = { "ab", "", "c", "de" };
var letters = words.SelectMany(word => word); // 'a', 'b', 'c', 'd', 'e'
```
